#!/usr/bin/env bash
# todo-fsr.04 (aka taskfer)

# See TODO_for_taskfer for change history and plans.
#
# CHANGES in .04
#
# Added recurrent entry, -r or -recur (use words like
# day, week, month for daily, weekly, monthly.
# NOTE: This entry method bypasses the date test.
# Moved test for argument out of -k and -tc function. 
#
#
# CHANGES in .03d.9
#
# Fixed problem with today's date for date_test.
# Moved ddt, d1, d0 out of options loop, into test_date, recall_due,
# and recall_due_c. 
# Added tab to the rest of the awk commands where it was missing. 
# Now recall_tag displays the tag, in case you want to search for
# a pattern that's common to two tags.
# Added test for argument to options -tc and -k, in the functions.
# Added more word options to some of the existing options:
# -add, -due, -key, -list, -tag, -week


# Tags can be up to six characters without screwing the alignment.

# kill_cal notes:
#   goes in options for any option with exit 0
#   goes in function if function ends with pager
#   goes in append_entry, and get there from test_date

# Functions are grouped into three categories:
#
# Entry functions, for making an entry to the tasklist:
#   append_enty - echoes the line into the tasklist.
#   ask_entry - asks for each field to be entered separately.
#   test_date - checks that due date is not in the past.
#
# Recall functions, to sort and display entries: 
#   by tag - recall_tag, recall_tag_c
#   by keyword - recall_keyword 
#   by due date - recall_due, recall_due_c, recall_week, recall_week_c. 
# The ones that end in _c will show the calender inline, instead of 
# spawning a new terminal, for use when running in console.
#   
# Delete functions, to remove entries from the tasklist.
#   del_line, ask_del - to remove one line at a time.
#   clean_old - remove all entries with old due dates.
#
# And then there are a few that don't fit a category.
#   taskfer_configuration - checks for config file settings.
#   show_cal - displays calendar in popup xterm
#   kill_cal - closes the popup calendar.
#   show_help - displays the help_text


# Some variables used in this script. This section is informational
# only. The variables get set in different places in the script.
#  
# duedate is the date you enter
# ddt is the due date converted to yy-mm-dd
# d0 is the beginning of today converted to seconds.
# d1 is some other date converted to seconds, for date arithmatic.
# days = number of days you enter for the -w option
# ln = line number
# nl is a linux command that displays a text file with line numbers.


# This directory will hold the tasklist file, a config file, and
# any temporary files that get used in running the script.
# A config file is not required, but makes it easier to change
# some defaults. 
# If you want taskfer to use a different directory, change it here.
taskfer_dir=$HOME/.taskfer


if ! [[ -d $taskfer_dir ]]
    then
        mkdir $taskfer_dir
fi

function taskfer_configuration {
    if [[ -f $taskfer_dir/taskferrc ]] ; then
        source $taskfer_dir/taskferrc
    fi
#
#    # check for values in $HOME/.taskfer/taskferrc and use them.
#    # if any are unset, this will set them.
    tasklist=${tasklist:="$taskfer_dir/tasklist"}
    tmplist=${tmplist:="$taskfer_dir/tmplist"}
    taskfer_pager=${taskfer_pager:=$(which less)}
    taskfer_editor=${taskfer_editor:=$(which vim)}
}

taskfer_configuration


# Check that X is running before starting cal in xterm
function show_cal {
if [[ -n $DISPLAY ]]
then
#    xterm -geometry 70x18+0+0  -hold -e cal -3  &
#    xterm -font -*-fixed-medium-r-*-*-20-*-*-*-*-*-iso8859-* -geometry 67x12+0+0 -hold -e cal -3 &  
    xterm -fa monaco -fs 11 -geometry 67x12+0+0 -hold -e cal -3 &
    xterm_pid="$!"
fi
}

# Check that xterm is still running before killing it
# Test if var is not null first, to avoid seeing the ps --help message
# when using the -a option.
function kill_cal {
if [[ -n "$xterm_pid" ]]
then
    if ps -p "$xterm_pid" > /dev/null
    then
        kill "$xterm_pid"
    fi
fi
}


#####@@@@@  ENTRY FUNCTIONS @@@@@#####

function append_entry {
     echo "$tag : $ddt : $text : Entered on $(date +%Y-%m-%d)" >> "$tasklist"
     echo
     echo "$tag : $ddt : $text : Entered on $(date +%Y-%m-%d)"
     echo
     kill_cal
exit 0
}

function test_date {
    beginday=$(date +%Y-%m-%d) 
    d0=$(date --date="$beginday" +%s)
    ddt=$(date --date="$duedate" +%F)
    d1=$(date --date="$ddt" +%s)
    if (("$d1" < "$d0"))
    then echo " 
      Due date is in the past!
      Are you sure you want to continue?
      (y,N): "
      read answer
      case "$answer" in
          [Yy]) append_entry ;;
             *) exit 0 ;;
      esac
    else
      append_entry
    fi
}

function ask_entry {
    cal -3
    echo
    echo
    tag=
    duedate=
    text=
    echo "Tag: "
    read tag
    echo "Date task is due.  (use *any* format): "
    read duedate
    echo "Message: "
    read text
    test_date
exit 0
}

# for an entry that recurs weekly, daily, monthly
function recurrent {
    cal -3 &
    sleep 1
    echo "
    Enter all fields, separated by semi-colon, as below,
    where repeats=number of recurrences and cycle=length of time
    between recurrences (day, week, month).
  
    <tag> ; <due date> ; <message> ; <repeats> ; <cycle>
    "
    read line
        if [[ $line == *\;*\;*\;*\;* ]]
        then
            tag=$(echo "$line" | awk -F ";" '{ print $1 }')
            duedate=$(echo "$line" | awk -F ";" '{ print $2 }')
            text=$(echo "$line" | awk -F ";" '{ print $3 }')
            repeats=$(echo "$line" | awk -F ";" '{ gsub(/ /,"") ; print $4 }')
            cycle=$(echo "$line" | awk -F ";" '{  print $5 }')
        else 
            echo "nothing was entered
            " ;  exit 0
        fi

    count=0
    ddt=$(date --date="$duedate" +%Y-%m-%d)
    until [[ "$count" = "$repeats" ]]
    do     
        echo "$tag : $ddt : $text : Entered on $(date +%Y-%m-%d)" >> "$tasklist"
        ddt=$(date --date="$ddt + 1 $cycle" +%Y-%m-%d)
        ((count+=1))
    done
exit 0
}


#####@@@@@ RECALL FUNCTIONS @@@@@#####

function recall_tag {
while read line
do
    if [[ -n $(echo $line | cut -d":" -f1 | grep $tag) ]] ; then
        echo "$line" >> "$tmplist"
    fi
done < "$tasklist"
    if [[ -f $tmplist ]]
    then
      cat "$tmplist" | awk -F: '{ print $1 "\t" $2 $3 }' | sort -n  | "$taskfer_pager"
      kill_cal
      rm "$tmplist"
    else
      echo "No entries with tag \"$tag\""    
    fi
exit 0
}

function recall_tag_c {
while read line
do
    if [[ -n $(echo $line | cut -d":" -f1 | grep $tag) ]] ; then
        echo "$line" >> "$tmplist"
    fi
done < "$tasklist"
    if [[ -f $tmplist ]]
    then
      cal -3
      echo
      cat "$tmplist" | awk -F: '{ print $1 "\t" $2 $3 }' | sort -n
      rm "$tmplist"
    else
      echo "No entries with tag \"$tag\""    
    fi
echo
exit 0
}

# No cal on this one. Could be added.
function recall_due {
ddt=$(date --date="$duedate" +%F)
while read line
do
    if [[ -n $(echo $line | cut -d":" -f2 | grep $ddt) ]] ; then
        echo "$line" >> "$tmplist"
    fi
done < "$tasklist"
    if [[ -f $tmplist ]]
    then
      cat "$tmplist" | awk -F: '{ print $1 "\t" $2 $3 }' | sort | "$taskfer_pager"
      rm "$tmplist"    
    else
      echo "No entries with due date $ddt"
    fi
exit 0
}

# similar to above, with console mode calendar
function recall_due_c {
cal -3
echo
ddt=$(date --date="$duedate" +%F)
while read line
do
    if [[ -n $(echo $line | cut -d":" -f2 | grep $ddt) ]] ; then
        echo "$line" >> "$tmplist"
    fi
done < "$tasklist"
    if [[ -f $tmplist ]]
    then
      cat "$tmplist" | awk -F: '{ print $1 "\t" $2 $3 }' | sort 
      rm "$tmplist"    
    else
      echo "No entries with due date $ddt"
    fi
echo
exit 0
}

# start with today, recall due, then increment the date by 1 day
# $days is defined down in the options loop. If no argument is provided
# for the -w option, it defaults to 8. Otherwise, it's the number of 
# days provided on the command line. -w 3 will return today plus 3 
function recall_week {
    count=0
    ddt=$(date +%Y-%m-%d)
    until [[ "$count" = "$days" ]]
    do
        while read line
        do
          if [[ -n $(echo $line | cut -d":" -f2 | grep  $ddt) ]] ; then
          echo "$line" >> "$tmplist"
          fi
        done < "$tasklist"
      ddt=$(date --date="$ddt + 1 day" +%Y-%m-%d)
      ((count+=1))
    done
    if [[ -f $tmplist ]]
    then    
      cat "$tmplist" | sort -t: -k2 | awk -F: '{ print $1 "\t" $2 $3 }' | "$taskfer_pager"
      kill_cal
      rm "$tmplist"
    else
      echo "No tasks listed for next $days days"
    fi       
exit 0
}

function recall_week_c {
    cal -3
    echo
    count=0
    ddt=$(date +%Y-%m-%d)
    until [[ "$count" = "$days" ]]
    do
        while read line
        do
          if [[ -n $(echo $line | cut -d":" -f2 | grep  $ddt) ]] ; then
          echo "$line" >> "$tmplist"
          fi
        done < "$tasklist"
      ddt=$(date --date="$ddt + 1 day" +%Y-%m-%d)
      ((count+=1))
    done
    if [[ -f $tmplist ]]
    then    
        cat "$tmplist" | sort -t: -k2 | awk -F: '{ print $1 "\t" $2 $3 }' 
        rm "$tmplist"
    else
        echo "No tasks listed for next $days days"
    fi       
echo
exit 0
}

function recall_keyword {
cal -3
while read line
  do
      grep "$key" | awk -F: '{ print $1 "\t" $2 $3 }' | sort -n
  done < "$tasklist"
exit 0
}


#####@@@@@ DELETE FUNCTIONS @@@@@#####

function ask_del {
while true
  do
    echo "
    Delete a line?
    (y,N)
    "
    read answer
    case "$answer" in
      [Yy]) del_line ;;
         *) exit 0 ;;
    esac
  done
}

# Display the list with line numbers, ask which line to delete,
# read the answer, if none, run ask_del.
# If answer, check for up to four digits, then delete that line,
# and then run ask_del to see if you want to delete another.
# Anything other than numeric answer exits the script.
function del_line {
while true
  do
    ln=
    nl "$tasklist" | sort -n
    echo "
    Enter line number to delete,
    : "
    read ln
    if  [[ -z "$ln" ]]
    then
        echo "Nothing was entered"
        ask_del
    else
      case "$ln" in
      [0-9]|[0-9][0-9]|[0-9][0-9][0-9]|[0-9][0-9][0-9][0-9]) echo "Entry $ln will be deleted"
            sleep 1
            sed -i~ "$ln"'d'  "$tasklist" 
            ask_del ;;
       *) exit 0 ;;
      esac
    fi
  done
}

# Same as del_line, but diplay reverse order.
function rdel_line {
while true 
  do
    ln=
    nl "$tasklist" | sort -rn
    echo "
    Enter line number to delete,
    : "
    read ln
    if  [[ -z "$ln" ]]
    then
        echo "Nothing was entered"
        ask_del
    else
      case "$ln" in
      [0-9]|[0-9][0-9]|[0-9][0-9][0-9]|[0-9][0-9][0-9][0-9]) echo "Entry $ln will be deleted"
            sleep 1
            sed -i~ "$ln"'d'  "$tasklist" 
            ask_del ;;
       *) exit 0 ;;
      esac
    fi
  done
}

# select entries with due dates no older than today's start, put them in
# tmplist, make a backup copy of tasklist and replace the tasklist 
# with the list of newer entries.
function clean_old {
while read line
  do
    ddt=$(echo $line | cut -d":" -f2)
    d1=$(date --date="$ddt" +%s)
        if (("$d1" > "$d0"))
        then
        echo "$line" >> "$tmplist"
        fi
  done < "$tasklist"
    mv "$tasklist" "$tasklist"~
    mv "$tmplist" "$tasklist"
    echo "Old entries removed from task list.
A backup of the old list was made at:

    $tasklist~
          "
exit 0
}

### END OF GROUPED FUNCTIONS


function show_help {
    printf "$help_text" 
    exit 0
}

help_text="\n 
  Usage: $0  <option> [arguments]\n
  valid options: 
    -a, -add        add/append entry to task list. Free-form dates with
                    spaces need to be quoted. Message may need quotes.
                        todo -a <tag> <due-date> <message>

    -d, -due [date] recall entries by due date, quotes not needed.
                    No argument shows tasks due today.

    -x, -del        delete a line from the task list
                    -xr  or -rdel reverses the sort
              
    -e, -edit       edit the task list. 

    -h, --help      display this help and exit

    -i              interactive entry

    -k <keyword>    recall entries by keyword or phrase

    -l, -list       list all entries. 
    
    -r, -recur      enter a recurrent event.

    -t <tag>        recall entries by tag

    -w  [n]         recall next [n] days; default 8 (incl. today)
    
    -clean          removes entries older than today
    
    -dc, -tc, -wc   same as the respective options above, 
                    but for console mode. (inline calendar)
     
     "
       
clear; date
echo 


# If no options are given on the command line, ask for input.
if [[ -z "$*" ]]
then
    cal -3 &
    sleep 1
    echo "
    Enter all fields, separated by semi-colon.
    <tag> ; <due date> ; <message>
    "
    read line
        if [[ $line == *\;*\;* ]]
        then
            tag=$(echo "$line" | awk -F ";" '{ print $1 }')
            duedate=$(echo "$line" | awk -F ";" '{ print $2 }')
            text=$(echo "$line" | awk -F ";" '{ print $3 }')
            test_date
        else 
            echo "nothing was entered
            " ;  exit 0
        fi
fi

# If the -t option is used (recall by tags) make sure a tag is given.
if [[ "$1" = "-t" ]]  && [[ -z "$2" ]]
then
    echo "
    Missing argument.
    Usage: $0 -t <tag>
    "
    exit 1
fi

if [[ "$1" = "-tc" ]]  && [[ -z "$2" ]]
then
    echo "
    Missing argument.
    Usage: $0 -t <tag>
    "
    exit 1
fi

if [[ "$1" = "-k" ]] && [[ -z "$2" ]]
then
    echo "
    Missing argument.
    Usage: $0 -k <keyword or phrase>
    "
    exit 1
fi

### COMMAND LINE OPTIONS        
while [[ $1 == -* ]]
do
    case "$1" in
      -a|-add) shift ; tag="$1" ; shift ; duedate="$1" ; shift ; text="$@" ; test_date ;;
      -d|-due) shift ; duedate="$@" ; recall_due ;;
      -dc) shift ; duedate="$@" ; recall_due_c ;;
      -x|-del|--del) del_line ;;
      -xr|-rdel|--rdel) rdel_line ;;
      -e|-edit) "$taskfer_editor" "$tasklist" ; exit 0 ;;
      -h|--help|-\?) show_help; exit 0;;
      -i) show_cal ; ask_entry ;;
      -k|-key) key="$2" ; recall_keyword ;;
      -l|-list) show_cal ; cat "$tasklist" | sort -t: -k2 | awk -F: '{ print $1 "\t" $2 $3 }' | "$taskfer_pager" ; kill_cal ; exit 0 ;;
      -r|-recur) recurrent ;;
      -t|-tag) show_cal ; tag="$2" ; recall_tag ;;
      -tc) tag="$2" ; recall_tag_c ;;
      -w|-week) show_cal ; if [[ "$2" ]] ; then days="$2" ; else days=8 ; fi ; recall_week ;;
      -wc) if [[ "$2" ]] ; then days="$2" ; else days=8 ; fi ; recall_week_c ;;
      -clean) clean_old ;;
       *) echo "
    invalid option: $1
    
    $0 -h for full help.
    "
                1>&2; exit 1;;
    esac
done
